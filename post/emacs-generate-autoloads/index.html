<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Emacs generate autoloads | Chuck</title>
<meta name=keywords content="autoload"><meta name=description content="The autoload facility lets you register the existence of a function or macro, but put off loading the file that defines it. The first call to the function automatically loads the proper library, in order to install the real definition and other associated code, then runs the real definition as if it had been loaded all along. Autoloading can also be triggered by looking up the documentation of the function or macro.
A magic autoload comment (often called an autoload cookie) consists of ;;;###autoload, on a line by itself, just before the real definition of the function in its autoloadable source file. The command M-x update-file-autoloads writes a corresponding autoload call into loaddefs.el. (The string that serves as the autoload cookie and the name of the file generated by update-file-autoloads can be changed from the above defaults, see below.) Building Emacs loads loaddefs.el and thus calls autoload. M-x update-directory-autoloads is even more powerful; it updates autoloads for all files in the current directory."><meta name=author content="Chuck"><link rel=canonical href=https://xuchengpeng.github.io/hugo-blog/post/emacs-generate-autoloads/><link crossorigin=anonymous href=/hugo-blog/assets/css/stylesheet.6a1981a06069ce515e31f1650c200b27bf6710e07287d012d0847047ba995307.css integrity="sha256-ahmBoGBpzlFeMfFlDCALJ79nEOByh9AS0IRwR7qZUwc=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/hugo-blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://xuchengpeng.github.io/hugo-blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xuchengpeng.github.io/hugo-blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://xuchengpeng.github.io/hugo-blog/favicon-32x32.png><link rel=apple-touch-icon href=https://xuchengpeng.github.io/hugo-blog/apple-touch-icon.png><link rel=mask-icon href=https://xuchengpeng.github.io/hugo-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Emacs generate autoloads"><meta property="og:description" content="The autoload facility lets you register the existence of a function or macro, but put off loading the file that defines it. The first call to the function automatically loads the proper library, in order to install the real definition and other associated code, then runs the real definition as if it had been loaded all along. Autoloading can also be triggered by looking up the documentation of the function or macro.
A magic autoload comment (often called an autoload cookie) consists of ;;;###autoload, on a line by itself, just before the real definition of the function in its autoloadable source file. The command M-x update-file-autoloads writes a corresponding autoload call into loaddefs.el. (The string that serves as the autoload cookie and the name of the file generated by update-file-autoloads can be changed from the above defaults, see below.) Building Emacs loads loaddefs.el and thus calls autoload. M-x update-directory-autoloads is even more powerful; it updates autoloads for all files in the current directory."><meta property="og:type" content="article"><meta property="og:url" content="https://xuchengpeng.github.io/hugo-blog/post/emacs-generate-autoloads/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-09-06T11:25:46+08:00"><meta property="article:modified_time" content="2018-09-06T11:25:46+08:00"><meta property="og:site_name" content="Chuck"><meta name=twitter:card content="summary"><meta name=twitter:title content="Emacs generate autoloads"><meta name=twitter:description content="The autoload facility lets you register the existence of a function or macro, but put off loading the file that defines it. The first call to the function automatically loads the proper library, in order to install the real definition and other associated code, then runs the real definition as if it had been loaded all along. Autoloading can also be triggered by looking up the documentation of the function or macro.
A magic autoload comment (often called an autoload cookie) consists of ;;;###autoload, on a line by itself, just before the real definition of the function in its autoloadable source file. The command M-x update-file-autoloads writes a corresponding autoload call into loaddefs.el. (The string that serves as the autoload cookie and the name of the file generated by update-file-autoloads can be changed from the above defaults, see below.) Building Emacs loads loaddefs.el and thus calls autoload. M-x update-directory-autoloads is even more powerful; it updates autoloads for all files in the current directory."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://xuchengpeng.github.io/hugo-blog/post/"},{"@type":"ListItem","position":3,"name":"Emacs generate autoloads","item":"https://xuchengpeng.github.io/hugo-blog/post/emacs-generate-autoloads/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Emacs generate autoloads","name":"Emacs generate autoloads","description":"The autoload facility lets you register the existence of a function or macro, but put off loading the file that defines it. The first call to the function automatically loads the proper library, in order to install the real definition and other associated code, then runs the real definition as if it had been loaded all along. Autoloading can also be triggered by looking up the documentation of the function or macro.\nA magic autoload comment (often called an autoload cookie) consists of ;;;###autoload, on a line by itself, just before the real definition of the function in its autoloadable source file. The command M-x update-file-autoloads writes a corresponding autoload call into loaddefs.el. (The string that serves as the autoload cookie and the name of the file generated by update-file-autoloads can be changed from the above defaults, see below.) Building Emacs loads loaddefs.el and thus calls autoload. M-x update-directory-autoloads is even more powerful; it updates autoloads for all files in the current directory.\n","keywords":["autoload"],"articleBody":"The autoload facility lets you register the existence of a function or macro, but put off loading the file that defines it. The first call to the function automatically loads the proper library, in order to install the real definition and other associated code, then runs the real definition as if it had been loaded all along. Autoloading can also be triggered by looking up the documentation of the function or macro.\nA magic autoload comment (often called an autoload cookie) consists of ;;;###autoload, on a line by itself, just before the real definition of the function in its autoloadable source file. The command M-x update-file-autoloads writes a corresponding autoload call into loaddefs.el. (The string that serves as the autoload cookie and the name of the file generated by update-file-autoloads can be changed from the above defaults, see below.) Building Emacs loads loaddefs.el and thus calls autoload. M-x update-directory-autoloads is even more powerful; it updates autoloads for all files in the current directory.\nupdate-file-autoloads (let ((dotemacs-autoload-file (concat dotemacs-cache-dir \"autoloads.el\"))) (update-file-autoloads file1 t dotemacs-autoload-file) (update-file-autoloads file2 t dotemacs-autoload-file) (update-file-autoloads ... t dotemacs-autoload-file)) update-directory-autoloads (let ((generated-autoload-file (concat dotemacs-cache-dir \"autoloads.el\"))) (when (not (file-exists-p generated-autoload-file)) (with-current-buffer (find-file-noselect generated-autoload-file) (insert \";;\") ;; create the file with non-zero size to appease autoload (save-buffer))) (mapc #'update-directory-autoloads '(\"\" \"dir1\" \"dir2\" \"dir3\"))) ","wordCount":"213","inLanguage":"en","datePublished":"2018-09-06T11:25:46+08:00","dateModified":"2018-09-06T11:25:46+08:00","author":{"@type":"Person","name":"Chuck"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xuchengpeng.github.io/hugo-blog/post/emacs-generate-autoloads/"},"publisher":{"@type":"Organization","name":"Chuck","logo":{"@type":"ImageObject","url":"https://xuchengpeng.github.io/hugo-blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xuchengpeng.github.io/hugo-blog accesskey=h title="Chuck (Alt + H)"><img src=https://xuchengpeng.github.io/apple-touch-icon.png alt aria-label=logo height=35>Chuck</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xuchengpeng.github.io/hugo-blog/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://xuchengpeng.github.io/hugo-blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://xuchengpeng.github.io/hugo-blog/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://xuchengpeng.github.io/hugo-blog/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://xuchengpeng.github.io/hugo-blog/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xuchengpeng.github.io/hugo-blog>Home</a>&nbsp;»&nbsp;<a href=https://xuchengpeng.github.io/hugo-blog/post/>Posts</a></div><h1 class=post-title>Emacs generate autoloads</h1><div class=post-meta>&lt;span title='2018-09-06 11:25:46 +0800 +0800'>September 6, 2018&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;213 words&amp;nbsp;·&amp;nbsp;Chuck&nbsp;|&nbsp;<a href=https://github.com/xuchengpeng/xuchengpeng.github.io/tree/main/content/post/emacs-generate-autoloads.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><ul><li><a href=#update-file-autoloads>update-file-autoloads</a></li><li><a href=#update-directory-autoloads>update-directory-autoloads</a></li></ul></li></ul></nav></div></details></div><div class=post-content><p>The autoload facility lets you register the existence of a function or macro, but put off loading the file that defines it. The first call to the function automatically loads the proper library, in order to install the real definition and other associated code, then runs the real definition as if it had been loaded all along. Autoloading can also be triggered by looking up the documentation of the function or macro.</p><p>A magic autoload comment (often called an autoload cookie) consists of <code>;;;###autoload</code>, on a line by itself, just before the real definition of the function in its autoloadable source file. The command <code>M-x update-file-autoloads</code> writes a corresponding autoload call into loaddefs.el. (The string that serves as the autoload cookie and the name of the file generated by <code>update-file-autoloads</code> can be changed from the above defaults, see below.) Building Emacs loads loaddefs.el and thus calls autoload. <code>M-x update-directory-autoloads</code> is even more powerful; it updates autoloads for all files in the current directory.</p><h3 id=update-file-autoloads>update-file-autoloads<a hidden class=anchor aria-hidden=true href=#update-file-autoloads>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-el data-lang=el><span class=line><span class=cl><span class=p>(</span><span class=nb>let</span> <span class=p>((</span><span class=nv>dotemacs-autoload-file</span> <span class=p>(</span><span class=nf>concat</span> <span class=nv>dotemacs-cache-dir</span> <span class=s>&#34;autoloads.el&#34;</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>update-file-autoloads</span> <span class=nv>file1</span> <span class=no>t</span> <span class=nv>dotemacs-autoload-file</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>update-file-autoloads</span> <span class=nv>file2</span> <span class=no>t</span> <span class=nv>dotemacs-autoload-file</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>update-file-autoloads</span> <span class=o>...</span>   <span class=no>t</span> <span class=nv>dotemacs-autoload-file</span><span class=p>))</span>
</span></span></code></pre></div><h3 id=update-directory-autoloads>update-directory-autoloads<a hidden class=anchor aria-hidden=true href=#update-directory-autoloads>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-el data-lang=el><span class=line><span class=cl><span class=p>(</span><span class=nb>let</span> <span class=p>((</span><span class=nv>generated-autoload-file</span> <span class=p>(</span><span class=nf>concat</span> <span class=nv>dotemacs-cache-dir</span> <span class=s>&#34;autoloads.el&#34;</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nb>when</span> <span class=p>(</span><span class=nv>not</span> <span class=p>(</span><span class=nf>file-exists-p</span> <span class=nv>generated-autoload-file</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nb>with-current-buffer</span> <span class=p>(</span><span class=nv>find-file-noselect</span> <span class=nv>generated-autoload-file</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nf>insert</span> <span class=s>&#34;;;&#34;</span><span class=p>)</span> <span class=c1>;; create the file with non-zero size to appease autoload</span>
</span></span><span class=line><span class=cl>      <span class=p>(</span><span class=nv>save-buffer</span><span class=p>)))</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nf>mapc</span> <span class=nf>#&#39;</span><span class=nv>update-directory-autoloads</span>
</span></span><span class=line><span class=cl>        <span class=o>&#39;</span><span class=p>(</span><span class=s>&#34;&#34;</span> <span class=s>&#34;dir1&#34;</span> <span class=s>&#34;dir2&#34;</span> <span class=s>&#34;dir3&#34;</span><span class=p>)))</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://xuchengpeng.github.io/hugo-blog/tags/autoload/>autoload</a></li></ul><nav class=paginav><a class=prev href=https://xuchengpeng.github.io/hugo-blog/post/cloud-and-edge-computing/><span class=title>« Prev</span><br><span>云计算与边缘计算</span>
</a><a class=next href=https://xuchengpeng.github.io/hugo-blog/post/emacs-proxy/><span class=title>Next »</span><br><span>Emacs Proxy</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=xuchengpeng/hugo-blog data-repo-id="MDEwOlJlcG9zaXRvcnkxNDA1MzI1NTA=" data-category=Comments data-category-id=DIC_kwDOCGBbRs4CUv2b data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2024 <a href=https://xuchengpeng.github.io/hugo-blog>Chuck</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>