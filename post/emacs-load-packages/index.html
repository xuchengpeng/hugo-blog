<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Emacs load packages | Chuck</title><meta name=keywords content="require,autoload,with-eval-after-load,use-package"><meta name=description content="load
load → is the general function for loading a file.
(load FILE &optional NOERROR NOMESSAGE NOSUFFIX MUST-SUFFIX)
举个例子，如果你的代码是 (load &#34;x&#34;)，emacs 将从 load-path 中尝试加载 x.elc、x.el、x 文件。
load-file
load-file → load one specific file. The file name argument should contain file name extension, such as .el .elc
(load-file file_name) just calls (load (expand-file-name file_name) nil nil t)
Use load-file when you have a specific full path of a file in mind.
举个例子：
load-file &#34;~/.emacs.d/lisp/init-example.el&#34;
这是最为原始的方式，填写的路径必须是绝对路径，这个路径也不会加入到emacs中load-path里。它也不会优先寻找编译过.elc文件（显然编译过文件的会更快些）。这种方式已经被抛弃，仅作为历史提一下。"><meta name=author content="Chuck"><link rel=canonical href=https://xuchengpeng.github.io/post/emacs-load-packages/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.bccfefac377bc340f06c260aed1bddf49a4354816d7c570d6aac75a997986c95.css integrity="sha256-vM/vrDd7w0DwbCYK7Rvd9JpDVIFtfFcNaqx1qZeYbJU=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://xuchengpeng.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://xuchengpeng.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://xuchengpeng.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://xuchengpeng.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://xuchengpeng.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=text/javascript async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
    MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        displayMath: [['$$','$$'], ['\[','\]']],
        processEscapes: true,
        processEnvironments: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre','code'],
        TeX: { equationNumbers: { autoNumber: "AMS" },
            extensions: ["AMSmath.js", "AMSsymbols.js"] }
    }
    });
    </script><meta property="og:title" content="Emacs load packages"><meta property="og:description" content="load
load → is the general function for loading a file.
(load FILE &optional NOERROR NOMESSAGE NOSUFFIX MUST-SUFFIX)
举个例子，如果你的代码是 (load &#34;x&#34;)，emacs 将从 load-path 中尝试加载 x.elc、x.el、x 文件。
load-file
load-file → load one specific file. The file name argument should contain file name extension, such as .el .elc
(load-file file_name) just calls (load (expand-file-name file_name) nil nil t)
Use load-file when you have a specific full path of a file in mind.
举个例子：
load-file &#34;~/.emacs.d/lisp/init-example.el&#34;
这是最为原始的方式，填写的路径必须是绝对路径，这个路径也不会加入到emacs中load-path里。它也不会优先寻找编译过.elc文件（显然编译过文件的会更快些）。这种方式已经被抛弃，仅作为历史提一下。"><meta property="og:type" content="article"><meta property="og:url" content="https://xuchengpeng.github.io/post/emacs-load-packages/"><meta property="og:image" content="https://xuchengpeng.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-05-11T13:51:45+00:00"><meta property="article:modified_time" content="2018-05-11T13:51:45+00:00"><meta property="og:site_name" content="ExampleSite"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://xuchengpeng.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Emacs load packages"><meta name=twitter:description content="load
load → is the general function for loading a file.
(load FILE &optional NOERROR NOMESSAGE NOSUFFIX MUST-SUFFIX)
举个例子，如果你的代码是 (load &#34;x&#34;)，emacs 将从 load-path 中尝试加载 x.elc、x.el、x 文件。
load-file
load-file → load one specific file. The file name argument should contain file name extension, such as .el .elc
(load-file file_name) just calls (load (expand-file-name file_name) nil nil t)
Use load-file when you have a specific full path of a file in mind.
举个例子：
load-file &#34;~/.emacs.d/lisp/init-example.el&#34;
这是最为原始的方式，填写的路径必须是绝对路径，这个路径也不会加入到emacs中load-path里。它也不会优先寻找编译过.elc文件（显然编译过文件的会更快些）。这种方式已经被抛弃，仅作为历史提一下。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://xuchengpeng.github.io/post/"},{"@type":"ListItem","position":2,"name":"Emacs load packages","item":"https://xuchengpeng.github.io/post/emacs-load-packages/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Emacs load packages","name":"Emacs load packages","description":"load load → is the general function for loading a file.\n(load FILE \u0026amp;optional NOERROR NOMESSAGE NOSUFFIX MUST-SUFFIX) 举个例子，如果你的代码是 (load \u0026quot;x\u0026quot;)，emacs 将从 load-path 中尝试加载 x.elc、x.el、x 文件。\nload-file load-file → load one specific file. The file name argument should contain file name extension, such as .el .elc\n(load-file file_name) just calls (load (expand-file-name file_name) nil nil t)\nUse load-file when you have a specific full path of a file in mind.\n举个例子：\nload-file \u0026#34;~/.emacs.d/lisp/init-example.el\u0026#34; 这是最为原始的方式，填写的路径必须是绝对路径，这个路径也不会加入到emacs中load-path里。它也不会优先寻找编译过.elc文件（显然编译过文件的会更快些）。这种方式已经被抛弃，仅作为历史提一下。\n","keywords":["require","autoload","with-eval-after-load","use-package"],"articleBody":"load load → is the general function for loading a file.\n(load FILE \u0026optional NOERROR NOMESSAGE NOSUFFIX MUST-SUFFIX) 举个例子，如果你的代码是 (load \"x\")，emacs 将从 load-path 中尝试加载 x.elc、x.el、x 文件。\nload-file load-file → load one specific file. The file name argument should contain file name extension, such as .el .elc\n(load-file file_name) just calls (load (expand-file-name file_name) nil nil t)\nUse load-file when you have a specific full path of a file in mind.\n举个例子：\nload-file \"~/.emacs.d/lisp/init-example.el\" 这是最为原始的方式，填写的路径必须是绝对路径，这个路径也不会加入到emacs中load-path里。它也不会优先寻找编译过.elc文件（显然编译过文件的会更快些）。这种方式已经被抛弃，仅作为历史提一下。\nrequire require → Load a package if it has not already been loaded.\n(require FEATURE \u0026optional FILENAME NOERROR) require checks if the symbol FEATURE is in variable features. If not, then it calls load to load it.\nFile name is guessed from the feature name FEATURE, or specified in the optional argument.\nrequire is best used in elisp libraries or scripts, similar to other language’s “require” or “import”.\n举个例子： init-example.el\n... your code here ... (provide 'init-example) init.el\n... your code here ... (require 'init-example) autoload autoload → Load a file only when a function is called.\n(autoload FUNCTION FILE \u0026optional DOCSTRING INTERACTIVE TYPE) autoload associates a function name with a file path. When the function is called, load the file, and execute the function.\nIf you are writing a major mode, have your package installation go by autoload if possible. It saves startup time.\n举个例子：\n(autoload 'python-mode \"python-mode\" \"Python Mode.\" t) with-eval-after-load If you want code to be executed when a particular library is loaded, use the macro with-eval-after-load.\nwith-eval-after-load is like the old eval-after-load, but better behaved.\neval-after-load is considered ill-behaved because it is a function, not a macro, and thus requires the code inside it to be quoted, which means that it cannot be byte-compiled. It also accepts only one form, so if you have more than one, you need to use progn. For example:\n(eval-after-load \"foo\" '(progn (setq foo 42) (setq bar 17))) The equivalent version with with-eval-after-load would be:\n(with-eval-after-load \"foo\" (setq foo 42) (setq bar 17)) Define a macro after-load which is compatible with both with-eval-after-load and eval-after-load.\n(if (fboundp 'with-eval-after-load) (defalias 'after-load 'with-eval-after-load) (defmacro after-load (feature \u0026rest body) \"After FEATURE is loaded, evaluate BODY.\" (declare (indent defun)) `(eval-after-load ,feature '(progn ,@body)))) use-package The use-package macro allows you to isolate package configuration in your .emacs file in a way that is both performance-oriented and, well, tidy. For more information, visit https://jwiegley.github.io/use-package .\n","wordCount":"392","inLanguage":"en","datePublished":"2018-05-11T13:51:45Z","dateModified":"2018-05-11T13:51:45Z","author":{"@type":"Person","name":"Chuck"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xuchengpeng.github.io/post/emacs-load-packages/"},"publisher":{"@type":"Organization","name":"Chuck","logo":{"@type":"ImageObject","url":"https://xuchengpeng.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xuchengpeng.github.io/ accesskey=h title="Chuck (Alt + H)"><img src=https://xuchengpeng.github.io/apple-touch-icon.png alt aria-label=logo height=35>Chuck</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xuchengpeng.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://xuchengpeng.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://xuchengpeng.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://xuchengpeng.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://xuchengpeng.github.io/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xuchengpeng.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://xuchengpeng.github.io/post/>Posts</a></div><h1 class=post-title>Emacs load packages</h1><div class=post-meta><span title='2018-05-11 13:51:45 +0000 UTC'>May 11, 2018</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;392 words&nbsp;·&nbsp;Chuck&nbsp;|&nbsp;<a href=https://github.com/xuchengpeng/xuchengpeng.github.io/tree/main/content/post/emacs-load-packages.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#load>load</a></li><li><a href=#load-file>load-file</a></li><li><a href=#require>require</a></li><li><a href=#autoload>autoload</a></li><li><a href=#with-eval-after-load>with-eval-after-load</a></li><li><a href=#use-packagehttpsgithubcomjwiegleyuse-package><a href=https://github.com/jwiegley/use-package>use-package</a></a></li></ul></nav></div></details></div><div class=post-content><h2 id=load>load<a hidden class=anchor aria-hidden=true href=#load>#</a></h2><p>load → is the general function for loading a file.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-el data-lang=el><span class=line><span class=cl><span class=p>(</span><span class=nv>load</span> <span class=nv>FILE</span> <span class=nv>&amp;optional</span> <span class=nv>NOERROR</span> <span class=nv>NOMESSAGE</span> <span class=nv>NOSUFFIX</span> <span class=nv>MUST-SUFFIX</span><span class=p>)</span>
</span></span></code></pre></div><p>举个例子，如果你的代码是 <code>(load "x")</code>，emacs 将从 load-path 中尝试加载 x.elc、x.el、x 文件。</p><h2 id=load-file>load-file<a hidden class=anchor aria-hidden=true href=#load-file>#</a></h2><p>load-file → load one specific file. The file name argument should contain file name extension, such as .el .elc</p><p><code>(load-file file_name)</code> just calls <code>(load (expand-file-name file_name) nil nil t)</code></p><p>Use load-file when you have a specific full path of a file in mind.</p><p>举个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-el data-lang=el><span class=line><span class=cl><span class=nv>load-file</span> <span class=s>&#34;~/.emacs.d/lisp/init-example.el&#34;</span>
</span></span></code></pre></div><p>这是最为原始的方式，填写的路径必须是绝对路径，这个路径也不会加入到emacs中load-path里。它也不会优先寻找编译过.elc文件（显然编译过文件的会更快些）。这种方式已经被抛弃，仅作为历史提一下。</p><h2 id=require>require<a hidden class=anchor aria-hidden=true href=#require>#</a></h2><p>require → Load a package if it has not already been loaded.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-el data-lang=el><span class=line><span class=cl><span class=p>(</span><span class=nv>require</span> <span class=nv>FEATURE</span> <span class=nv>&amp;optional</span> <span class=nv>FILENAME</span> <span class=nv>NOERROR</span><span class=p>)</span>
</span></span></code></pre></div><p>require checks if the symbol FEATURE is in variable features. If not, then it calls load to load it.</p><p>File name is guessed from the feature name FEATURE, or specified in the optional argument.</p><p>require is best used in elisp libraries or scripts, similar to other language&rsquo;s “require” or “import”.</p><p>举个例子：
<em>init-example.el</em></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-el data-lang=el><span class=line><span class=cl><span class=o>...</span> <span class=nv>your</span> <span class=nv>code</span> <span class=nv>here</span> <span class=o>...</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nv>provide</span> <span class=ss>&#39;init-example</span><span class=p>)</span>
</span></span></code></pre></div><p><em>init.el</em></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-el data-lang=el><span class=line><span class=cl><span class=o>...</span> <span class=nv>your</span> <span class=nv>code</span> <span class=nv>here</span> <span class=o>...</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=nv>require</span> <span class=ss>&#39;init-example</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=autoload>autoload<a hidden class=anchor aria-hidden=true href=#autoload>#</a></h2><p>autoload → Load a file only when a function is called.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-el data-lang=el><span class=line><span class=cl><span class=p>(</span><span class=nv>autoload</span> <span class=nv>FUNCTION</span> <span class=nv>FILE</span> <span class=nv>&amp;optional</span> <span class=nv>DOCSTRING</span> <span class=nv>INTERACTIVE</span> <span class=nv>TYPE</span><span class=p>)</span>
</span></span></code></pre></div><p>autoload associates a function name with a file path. When the function is called, load the file, and execute the function.</p><p>If you are writing a major mode, have your package installation go by autoload if possible. It saves startup time.</p><p>举个例子：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-el data-lang=el><span class=line><span class=cl><span class=p>(</span><span class=nv>autoload</span> <span class=ss>&#39;python-mode</span> <span class=s>&#34;python-mode&#34;</span> <span class=s>&#34;Python Mode.&#34;</span> <span class=no>t</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=with-eval-after-load>with-eval-after-load<a hidden class=anchor aria-hidden=true href=#with-eval-after-load>#</a></h2><p>If you want code to be executed when a particular library is loaded, use the macro <code>with-eval-after-load</code>.</p><p><code>with-eval-after-load</code> is like the old <code>eval-after-load</code>, but better behaved.</p><p>eval-after-load is considered ill-behaved because it is a function, not a macro, and thus requires the code inside it to be quoted, which means that it cannot be byte-compiled. It also accepts only one form, so if you have more than one, you need to use progn. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-el data-lang=el><span class=line><span class=cl><span class=p>(</span><span class=nv>eval-after-load</span> <span class=s>&#34;foo&#34;</span>
</span></span><span class=line><span class=cl>  <span class=o>&#39;</span><span class=p>(</span><span class=nv>progn</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=nv>setq</span> <span class=nv>foo</span> <span class=mi>42</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=p>(</span><span class=nv>setq</span> <span class=nv>bar</span> <span class=mi>17</span><span class=p>)))</span>
</span></span></code></pre></div><p>The equivalent version with with-eval-after-load would be:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-el data-lang=el><span class=line><span class=cl><span class=p>(</span><span class=nv>with-eval-after-load</span> <span class=s>&#34;foo&#34;</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>setq</span> <span class=nv>foo</span> <span class=mi>42</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>setq</span> <span class=nv>bar</span> <span class=mi>17</span><span class=p>))</span>
</span></span></code></pre></div><p>Define a macro <code>after-load</code> which is compatible with both <code>with-eval-after-load</code> and <code>eval-after-load</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-el data-lang=el><span class=line><span class=cl><span class=p>(</span><span class=nv>if</span> <span class=p>(</span><span class=nv>fboundp</span> <span class=ss>&#39;with-eval-after-load</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>defalias</span> <span class=ss>&#39;after-load</span> <span class=ss>&#39;with-eval-after-load</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>(</span><span class=nv>defmacro</span> <span class=nv>after-load</span> <span class=p>(</span><span class=nv>feature</span> <span class=nv>&amp;rest</span> <span class=nv>body</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;After FEATURE is loaded, evaluate BODY.&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=nv>declare</span> <span class=p>(</span><span class=nv>indent</span> <span class=nv>defun</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=o>`</span><span class=p>(</span><span class=nv>eval-after-load</span> <span class=o>,</span><span class=nv>feature</span>
</span></span><span class=line><span class=cl>       <span class=o>&#39;</span><span class=p>(</span><span class=nv>progn</span> <span class=o>,@</span><span class=nv>body</span><span class=p>))))</span>
</span></span></code></pre></div><h2 id=use-packagehttpsgithubcomjwiegleyuse-package><a href=https://github.com/jwiegley/use-package>use-package</a><a hidden class=anchor aria-hidden=true href=#use-packagehttpsgithubcomjwiegleyuse-package>#</a></h2><p>The <code>use-package</code> macro allows you to isolate package configuration in your .emacs file in a way that is both performance-oriented and, well, tidy. For more information, visit <a href=https://jwiegley.github.io/use-package>https://jwiegley.github.io/use-package</a> .</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xuchengpeng.github.io/tags/require/>require</a></li><li><a href=https://xuchengpeng.github.io/tags/autoload/>autoload</a></li><li><a href=https://xuchengpeng.github.io/tags/with-eval-after-load/>with-eval-after-load</a></li><li><a href=https://xuchengpeng.github.io/tags/use-package/>use-package</a></li></ul><nav class=paginav><a class=prev href=https://xuchengpeng.github.io/post/tcp-ip-illustrated-volume1-dns/><span class=title>« Prev</span><br><span>TCP/IP 详解(卷一) DNS：域名系统</span></a>
<a class=next href=https://xuchengpeng.github.io/post/tcp-ip-illustrated-volume1-igmp/><span class=title>Next »</span><br><span>TCP/IP 详解(卷一) IGMP：Internet组管理协议</span></a></nav></footer><div class=article-comments><span id=/post/emacs-load-packages/ class=leancloud-visitors data-flag-title="Emacs load packages"><span class=post-meta-item-text>文章阅读量</span>
<span class=leancloud-visitors-count>0</span></span><div id=vcomments></div><script src=//unpkg.com/valine/dist/Valine.min.js></script>
<script type=text/javascript>new Valine({el:"#vcomments",appId:"8cGx0mI721mXnuSact0PLKmV-gzGzoHsz",appKey:"eQc0CtLv9s4VTdObz6ux8lVW",notify:"false",verify:"false",avatar:"wavatar",placeholder:"Leave your comments here...",visitor:"true"})</script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://xuchengpeng.github.io/>Chuck</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>