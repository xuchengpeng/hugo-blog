<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>TCP/IP 详解(卷一) BOOTP：引导程序协议 | Chuck</title>
<meta name=keywords content="BOOTP,ARP,RARP"><meta name=description content="一个无盘系统，它在不知道自身IP地址的情况下，在进行系统引导时能够通过RARP来获取它的IP地址。然而使用RARP有两个问题：（1）IP地址是返回的唯一结果；（2）既然RARP使用链路层广播，RARP请求就不会被路由器转发（迫使每个实际网络设置一个RARP服务器）。下面将介绍一种用于无盘系统进行系统引导的替代方法，又称为引导程序协议，或BOOTP。
BOOTP使用UDP，且通常需与TFTP协同工作。
BOOTP 的分组格式
BOOTP 请求和应答均被封装在UDP数据报中，IP首部(20字节) - UDP首部(8字节) - BOOTP请求/应答(300字节)。
“操作码”字段为1表示请求，为2表示应答。硬件类型字段为1表示10 Mb/s的以太网，这和ARP请求或应答中同名字段表示的含义相同。类似地，对于以太网，硬件地址长度字段为6字节。
“跳数”字段由客户设置为0，但也能被一个代理服务器设置。
“事务标识”字段是一个由客户设置并由服务器返回的32 bit整数。客户用它对请求和应答进行匹配。对每个请求，客户应该将该字段设置为一个随机数。
客户开始进行引导时，将“秒数”字段设置为一个时间值。服务器能够看到这个时间值，备用服务器在等待时间超过这个时间值后才会响应客户的请求，这意味着主服务器没有启动。"><meta name=author content="Chuck"><link rel=canonical href=https://xuchengpeng.github.io/hugo-blog/post/tcp-ip-illustrated-volume1-bootp/><link crossorigin=anonymous href=/hugo-blog/assets/css/stylesheet.6a1981a06069ce515e31f1650c200b27bf6710e07287d012d0847047ba995307.css integrity="sha256-ahmBoGBpzlFeMfFlDCALJ79nEOByh9AS0IRwR7qZUwc=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/hugo-blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://xuchengpeng.github.io/hugo-blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://xuchengpeng.github.io/hugo-blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://xuchengpeng.github.io/hugo-blog/favicon-32x32.png><link rel=apple-touch-icon href=https://xuchengpeng.github.io/hugo-blog/apple-touch-icon.png><link rel=mask-icon href=https://xuchengpeng.github.io/hugo-blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="TCP/IP 详解(卷一) BOOTP：引导程序协议"><meta property="og:description" content="一个无盘系统，它在不知道自身IP地址的情况下，在进行系统引导时能够通过RARP来获取它的IP地址。然而使用RARP有两个问题：（1）IP地址是返回的唯一结果；（2）既然RARP使用链路层广播，RARP请求就不会被路由器转发（迫使每个实际网络设置一个RARP服务器）。下面将介绍一种用于无盘系统进行系统引导的替代方法，又称为引导程序协议，或BOOTP。
BOOTP使用UDP，且通常需与TFTP协同工作。
BOOTP 的分组格式
BOOTP 请求和应答均被封装在UDP数据报中，IP首部(20字节) - UDP首部(8字节) - BOOTP请求/应答(300字节)。
“操作码”字段为1表示请求，为2表示应答。硬件类型字段为1表示10 Mb/s的以太网，这和ARP请求或应答中同名字段表示的含义相同。类似地，对于以太网，硬件地址长度字段为6字节。
“跳数”字段由客户设置为0，但也能被一个代理服务器设置。
“事务标识”字段是一个由客户设置并由服务器返回的32 bit整数。客户用它对请求和应答进行匹配。对每个请求，客户应该将该字段设置为一个随机数。
客户开始进行引导时，将“秒数”字段设置为一个时间值。服务器能够看到这个时间值，备用服务器在等待时间超过这个时间值后才会响应客户的请求，这意味着主服务器没有启动。"><meta property="og:type" content="article"><meta property="og:url" content="https://xuchengpeng.github.io/hugo-blog/post/tcp-ip-illustrated-volume1-bootp/"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-05-14T17:43:41+00:00"><meta property="article:modified_time" content="2018-05-14T17:43:41+00:00"><meta property="og:site_name" content="Chuck"><meta name=twitter:card content="summary"><meta name=twitter:title content="TCP/IP 详解(卷一) BOOTP：引导程序协议"><meta name=twitter:description content="一个无盘系统，它在不知道自身IP地址的情况下，在进行系统引导时能够通过RARP来获取它的IP地址。然而使用RARP有两个问题：（1）IP地址是返回的唯一结果；（2）既然RARP使用链路层广播，RARP请求就不会被路由器转发（迫使每个实际网络设置一个RARP服务器）。下面将介绍一种用于无盘系统进行系统引导的替代方法，又称为引导程序协议，或BOOTP。
BOOTP使用UDP，且通常需与TFTP协同工作。
BOOTP 的分组格式
BOOTP 请求和应答均被封装在UDP数据报中，IP首部(20字节) - UDP首部(8字节) - BOOTP请求/应答(300字节)。
“操作码”字段为1表示请求，为2表示应答。硬件类型字段为1表示10 Mb/s的以太网，这和ARP请求或应答中同名字段表示的含义相同。类似地，对于以太网，硬件地址长度字段为6字节。
“跳数”字段由客户设置为0，但也能被一个代理服务器设置。
“事务标识”字段是一个由客户设置并由服务器返回的32 bit整数。客户用它对请求和应答进行匹配。对每个请求，客户应该将该字段设置为一个随机数。
客户开始进行引导时，将“秒数”字段设置为一个时间值。服务器能够看到这个时间值，备用服务器在等待时间超过这个时间值后才会响应客户的请求，这意味着主服务器没有启动。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://xuchengpeng.github.io/hugo-blog/post/"},{"@type":"ListItem","position":3,"name":"TCP/IP 详解(卷一) BOOTP：引导程序协议","item":"https://xuchengpeng.github.io/hugo-blog/post/tcp-ip-illustrated-volume1-bootp/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"TCP/IP 详解(卷一) BOOTP：引导程序协议","name":"TCP\/IP 详解(卷一) BOOTP：引导程序协议","description":"一个无盘系统，它在不知道自身IP地址的情况下，在进行系统引导时能够通过RARP来获取它的IP地址。然而使用RARP有两个问题：（1）IP地址是返回的唯一结果；（2）既然RARP使用链路层广播，RARP请求就不会被路由器转发（迫使每个实际网络设置一个RARP服务器）。下面将介绍一种用于无盘系统进行系统引导的替代方法，又称为引导程序协议，或BOOTP。\nBOOTP使用UDP，且通常需与TFTP协同工作。\nBOOTP 的分组格式 BOOTP 请求和应答均被封装在UDP数据报中，IP首部(20字节) - UDP首部(8字节) - BOOTP请求/应答(300字节)。\n“操作码”字段为1表示请求，为2表示应答。硬件类型字段为1表示10 Mb/s的以太网，这和ARP请求或应答中同名字段表示的含义相同。类似地，对于以太网，硬件地址长度字段为6字节。\n“跳数”字段由客户设置为0，但也能被一个代理服务器设置。\n“事务标识”字段是一个由客户设置并由服务器返回的32 bit整数。客户用它对请求和应答进行匹配。对每个请求，客户应该将该字段设置为一个随机数。\n客户开始进行引导时，将“秒数”字段设置为一个时间值。服务器能够看到这个时间值，备用服务器在等待时间超过这个时间值后才会响应客户的请求，这意味着主服务器没有启动。\n","keywords":["BOOTP","ARP","RARP"],"articleBody":"一个无盘系统，它在不知道自身IP地址的情况下，在进行系统引导时能够通过RARP来获取它的IP地址。然而使用RARP有两个问题：（1）IP地址是返回的唯一结果；（2）既然RARP使用链路层广播，RARP请求就不会被路由器转发（迫使每个实际网络设置一个RARP服务器）。下面将介绍一种用于无盘系统进行系统引导的替代方法，又称为引导程序协议，或BOOTP。\nBOOTP使用UDP，且通常需与TFTP协同工作。\nBOOTP 的分组格式 BOOTP 请求和应答均被封装在UDP数据报中，IP首部(20字节) - UDP首部(8字节) - BOOTP请求/应答(300字节)。\n“操作码”字段为1表示请求，为2表示应答。硬件类型字段为1表示10 Mb/s的以太网，这和ARP请求或应答中同名字段表示的含义相同。类似地，对于以太网，硬件地址长度字段为6字节。\n“跳数”字段由客户设置为0，但也能被一个代理服务器设置。\n“事务标识”字段是一个由客户设置并由服务器返回的32 bit整数。客户用它对请求和应答进行匹配。对每个请求，客户应该将该字段设置为一个随机数。\n客户开始进行引导时，将“秒数”字段设置为一个时间值。服务器能够看到这个时间值，备用服务器在等待时间超过这个时间值后才会响应客户的请求，这意味着主服务器没有启动。\n如果该客户已经知道自身的IP地址，它将写入“客户IP地址”字段。否则，它将该字段设置为0。对于后面这种情况，服务器用该客户的IP地址写入“你的IP地址”字段。“服务器IP地址”字段则由服务器填写。如果使用了某个代理服务器，则该代理服务器就填写“网关IP地址”字段。\n客户必须设置它的“客户硬件地址”字段。尽管这个值与以太网数据帧头中的值相同，UDP数据报中也设置这个字段，但任何接收这个数据报的用户进程能很容易地获得它（例如一个BOOTP服务器）。一个进程通过查看UDP数据报来确定以太网帧首部中的该字段通常是很困难的（或者说是不可能的）。\n“服务器主机名”字段是一个空值终止串，由服务器填写。服务器还将在“引导文件名字段”填入包括用于系统引导的文件名及其所在位置的路径全名。\n“特定厂商区域”字段用于对BOOTP进行不同的扩展。\n当一个客户使用BOOTP（操作码为1）进行系统引导时，引导请求通常是采用链路层广播，IP首部中的目的IP地址为255.255.255.255（受限的广播）。源IP地址通常是0.0.0.0，因为此时客户还不知道它本身的IP地址。在系统进行自引导时，0.0.0.0是一个有效的IP地址。\n端口号\nBOOTP有两个熟知端口：BOOTP服务器为67，BOOTP客户为68。这意味着BOOTP客户不会选择未用的临时端口，而只用端口68。选择两个端口而不是仅选择一个端口为BOOTP服务器用的原因是：服务器的应答可以进行广播（但通常是不用广播的）。\n如果服务器的应答是通过广播传送的，同时客户又选择未用的临时端口，那么这些广播也能被其他的主机中碰巧使用相同临时端口的应用进程接收到。因此，采用随机端口（即临时端口）对广播来说是一个不好的选择。\n如果客户也使用服务器的知名端口（67）作为它的端口，那么网络内的所有服务器会被唤醒来查看每个广播应答（如果所有的服务器都被唤醒，它们将检查操作码，如果是一个应答而不是请求，就不作处理）。因此可以让所有的客户使用与服务器知名端口不同的同一知名端口。\n如果多个客户同时进行系统引导，并且服务器广播所有应答，这样每个客户都会收到其他客户的应答。客户可以通过BOOTP首部中的事务标识字段来确认应答是否与请求匹配，或者可以通过检查返回的客户硬件地址加以区分。\nBOOTP 服务器的设计 BOOTP客户通常固化在无盘系统只读存储器中，因此了解BOOTP服务器的实现将更有意义。\n首先，BOOTP服务器将从它的熟知端口（67）读取UDP数据报。这没有特别的地方。它不同于RARP服务器，它必须读取类型字段为“RARP请求”的以太网帧。BOOTP协议通过将客户的硬件地址放入BOOTP分组中，使得服务器很容易获取客户的硬件地址。\n这里出现了一个有趣的问题：TFTP服务器如何能将一个响应直接送回BOOTP客户？这个响应是一个UDP数据报，而服务器知道该客户的IP地址（可能通过读取服务器上的配置文件）。但如果这个客户向那个IP地址发送一个UDP数据报（正常情况下会处理UDP的输出），BOOTP服务器的主机就可能向那个IP地址发送一个ARP请求。但这个客户不能响应这个ARP请求，因为它还不知道它自己的IP地址！（这就是在RFC951中被称作“鸡和蛋”的问题。）\n有两种解决办法：第一种，通常被Unix服务器采用，是服务器发一个ioctl请求给内核，为该客户在ARP高速缓存中设置一个条目（这就是命令arp-s所做的作工）。服务器能一直这么做直到它知道客户的硬件地址和IP地址。这意味着当服务器发送UDP数据报（即BOOTP应答）时，服务器的ARP将在ARP高速缓存中找到该客户的IP地址。\n另一种可选的解决办法是服务器广播这个BOOTP应答而不直接将应答发回该客户。既然通常期望网络广播越少越好，因此这种解决方案应该只在服务器无法在它的ARP高速缓存设置一个条目的情况下使用。通常只有拥有超级用户权限才能在ARP高速缓存设置一个条目，如果没有这种权限就只能广播BOOTP应答。\nBOOTP 穿越路由器 RARP的一个缺点就是它使用链路层广播，这种广播通常不会由路由器转发。这就需要在每个物理网络内设置一个RARP服务器。如果路由器支持BOOTP协议，那么BOOTP能够由路由器转发（绝大多数路由器厂商的产品都支持这个功能）。\n这个功能主要用于无盘路由器，因为如果在磁盘的多用户系统被用作路由器，它就能够自己运行BOOTP服务器。此外，常用的Unix BOOTP服务器支持这种中继模式（relay mode）。但如果在这个物理网络内运行一个BOOTP服务器，通常没有必要将BOOTP请求转发到在另外网络中的另一个服务器。\n研究一下当路由器（也称作“BOOTP中继代理”）在服务器的熟知端口（67）接收到BOOTP请求时将会发生什么。当收到一个BOOTP请求时，中继代理将它的IP地址填入收到BOOTP请求中的“网关IP地址字段”，然后将该请求发送到真正的BOOTP服务器（由中继代理填入网关字段的地址是收到的BOOTP请求接口的IP地址）。该代理中继还将跳数字段值加1（这是为防止请求被无限地在网络内转发。RFC 951认为如果跳数值到达3就可以丢弃该请求）。既然发出的请求是一个单播的数据报（与发起的客户的请求是广播的相反），它能按照一定的路由通过其他的路由器到达真正的BOOTP服务器。真正的BOOTP服务器收到这个请求后，产生BOOTP应答，并将它发回中继代理，而不是请求的客户。既然请求网关字段不为零，真正的BOOTP服务器知道这个请求是经过转发的。中继代理收到应答后将它发给请求的客户。\n特定厂商信息 64字节的“特定厂商区域”含有服务器返回客户的可选信息。\n如果有信息要提供，这个区域的前4个字节被设置为IP地址99.130.83.99。这可称作魔术甜饼(magic cookie)，表示该区域内包含信息。\n这个区域的其余部分是一个条目表。每个条目的开始是1字节标志字段。其中的两个条目仅有标志字段：标志为0的条目作为填充字节（为使后面的条目有更好的字节边界），标志为255的条目表示结尾条目。第一个结尾条目后剩余的字节都应设置为这个数值（255）。\n除了这两个1字节的条目，其他的条目还包含一个单字节的长度字段，后面是相应的信息。\n子网掩码条目和时间值条目都是定长条目，因为它们的值总是占4个字节。时间偏移值是从1900年1月1日0时以来的秒数（UTC）。\n网关条目是变长条目。长度通常是4的倍数，这个值是一个或多个供客户使用的网关（路由器）的IP地址。返回的第一个必须是首选的网关。\nRFC 1533还定义了其他14个条目。其中最重要的可能是DNS名字服务器的IP地址条目，条目的志为6。其他的条目包括打印服务器、时间服务器等的IP地址。详细情况可参考RFC文档。\nHost Requirements RFC文档推荐一个系统使用BOOTP来获悉它的子网掩码，而不是采用ICMP。\n厂商说明区域的大小被限制为64字节。这对某些应用是个约束。一个新的称为动态主机配置协议DHCP（Dynamic Host Configuration Protocol）已经出现，但它不是替代BOOTP的。DHCP将这个区域的长度扩展到312字节，它在RFC 1541 [Droms 1993] 中定义。\n小结 BOOTP使用UDP，它为引导无盘系统获得它的IP地址提供了除RARP外的另外一种选择。BOOTP还能返回其他的信息，如路由器的IP地址、客户的子网掩码和名字服务器的IP地址。\n既然BOOTP用于系统引导过程，一个无盘系统需要下列协议才能在只读存储器中完成：BOOTP、TFTP、UDP、IP和一个局域网的驱动程序。\nBOOTP服务器比RARP服务器更易于实现，因为BOOTP请求和应答是在UDP数据报中，而不是特殊的数据链路层帧。一个路由器还能作为真正BOOTP服务器的代理，向位于不同网络的真正BOOTP服务器转发客户的BOOTP请求。\n","wordCount":"66","inLanguage":"en","datePublished":"2018-05-14T17:43:41Z","dateModified":"2018-05-14T17:43:41Z","author":{"@type":"Person","name":"Chuck"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://xuchengpeng.github.io/hugo-blog/post/tcp-ip-illustrated-volume1-bootp/"},"publisher":{"@type":"Organization","name":"Chuck","logo":{"@type":"ImageObject","url":"https://xuchengpeng.github.io/hugo-blog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://xuchengpeng.github.io/hugo-blog accesskey=h title="Chuck (Alt + H)"><img src=https://xuchengpeng.github.io/apple-touch-icon.png alt aria-label=logo height=35>Chuck</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://xuchengpeng.github.io/hugo-blog/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://xuchengpeng.github.io/hugo-blog/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://xuchengpeng.github.io/hugo-blog/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://xuchengpeng.github.io/hugo-blog/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://xuchengpeng.github.io/hugo-blog/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://xuchengpeng.github.io/hugo-blog>Home</a>&nbsp;»&nbsp;<a href=https://xuchengpeng.github.io/hugo-blog/post/>Posts</a></div><h1 class=post-title>TCP/IP 详解(卷一) BOOTP：引导程序协议</h1><div class=post-meta>&lt;span title='2018-05-14 17:43:41 +0000 UTC'>May 14, 2018&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;66 words&amp;nbsp;·&amp;nbsp;Chuck&nbsp;|&nbsp;<a href=https://github.com/xuchengpeng/xuchengpeng.github.io/tree/main/content/post/tcp-ip-illustrated-volume1-bootp.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#bootp-的分组格式>BOOTP 的分组格式</a></li><li><a href=#bootp-服务器的设计>BOOTP 服务器的设计</a></li><li><a href=#bootp-穿越路由器>BOOTP 穿越路由器</a></li><li><a href=#特定厂商信息>特定厂商信息</a></li><li><a href=#小结>小结</a></li></ul></nav></div></details></div><div class=post-content><p>一个无盘系统，它在不知道自身IP地址的情况下，在进行系统引导时能够通过RARP来获取它的IP地址。然而使用RARP有两个问题：（1）IP地址是返回的唯一结果；（2）既然RARP使用链路层广播，RARP请求就不会被路由器转发（迫使每个实际网络设置一个RARP服务器）。下面将介绍一种用于无盘系统进行系统引导的替代方法，又称为引导程序协议，或BOOTP。</p><p>BOOTP使用UDP，且通常需与TFTP协同工作。</p><h2 id=bootp-的分组格式>BOOTP 的分组格式<a hidden class=anchor aria-hidden=true href=#bootp-的分组格式>#</a></h2><p>BOOTP 请求和应答均被封装在UDP数据报中，IP首部(20字节) - UDP首部(8字节) - BOOTP请求/应答(300字节)。</p><p>“操作码”字段为1表示请求，为2表示应答。硬件类型字段为1表示10 Mb/s的以太网，这和ARP请求或应答中同名字段表示的含义相同。类似地，对于以太网，硬件地址长度字段为6字节。</p><p>“跳数”字段由客户设置为0，但也能被一个代理服务器设置。</p><p>“事务标识”字段是一个由客户设置并由服务器返回的32 bit整数。客户用它对请求和应答进行匹配。对每个请求，客户应该将该字段设置为一个随机数。</p><p>客户开始进行引导时，将“秒数”字段设置为一个时间值。服务器能够看到这个时间值，备用服务器在等待时间超过这个时间值后才会响应客户的请求，这意味着主服务器没有启动。</p><p>如果该客户已经知道自身的IP地址，它将写入“客户IP地址”字段。否则，它将该字段设置为0。对于后面这种情况，服务器用该客户的IP地址写入“你的IP地址”字段。“服务器IP地址”字段则由服务器填写。如果使用了某个代理服务器，则该代理服务器就填写“网关IP地址”字段。</p><p>客户必须设置它的“客户硬件地址”字段。尽管这个值与以太网数据帧头中的值相同，UDP数据报中也设置这个字段，但任何接收这个数据报的用户进程能很容易地获得它（例如一个BOOTP服务器）。一个进程通过查看UDP数据报来确定以太网帧首部中的该字段通常是很困难的（或者说是不可能的）。</p><p>“服务器主机名”字段是一个空值终止串，由服务器填写。服务器还将在“引导文件名字段”填入包括用于系统引导的文件名及其所在位置的路径全名。</p><p>“特定厂商区域”字段用于对BOOTP进行不同的扩展。</p><p>当一个客户使用BOOTP（操作码为1）进行系统引导时，引导请求通常是采用链路层广播，IP首部中的目的IP地址为255.255.255.255（受限的广播）。源IP地址通常是0.0.0.0，因为此时客户还不知道它本身的IP地址。在系统进行自引导时，0.0.0.0是一个有效的IP地址。</p><p><img loading=lazy src=/images/tcp-ip/bootp-format.jpg alt></p><p><strong>端口号</strong></p><p>BOOTP有两个熟知端口：BOOTP服务器为67，BOOTP客户为68。这意味着BOOTP客户不会选择未用的临时端口，而只用端口68。选择两个端口而不是仅选择一个端口为BOOTP服务器用的原因是：服务器的应答可以进行广播（但通常是不用广播的）。</p><p>如果服务器的应答是通过广播传送的，同时客户又选择未用的临时端口，那么这些广播也能被其他的主机中碰巧使用相同临时端口的应用进程接收到。因此，采用随机端口（即临时端口）对广播来说是一个不好的选择。</p><p>如果客户也使用服务器的知名端口（67）作为它的端口，那么网络内的所有服务器会被唤醒来查看每个广播应答（如果所有的服务器都被唤醒，它们将检查操作码，如果是一个应答而不是请求，就不作处理）。因此可以让所有的客户使用与服务器知名端口不同的同一知名端口。</p><p>如果多个客户同时进行系统引导，并且服务器广播所有应答，这样每个客户都会收到其他客户的应答。客户可以通过BOOTP首部中的事务标识字段来确认应答是否与请求匹配，或者可以通过检查返回的客户硬件地址加以区分。</p><h2 id=bootp-服务器的设计>BOOTP 服务器的设计<a hidden class=anchor aria-hidden=true href=#bootp-服务器的设计>#</a></h2><p>BOOTP客户通常固化在无盘系统只读存储器中，因此了解BOOTP服务器的实现将更有意义。</p><p>首先，BOOTP服务器将从它的熟知端口（67）读取UDP数据报。这没有特别的地方。它不同于RARP服务器，它必须读取类型字段为“RARP请求”的以太网帧。BOOTP协议通过将客户的硬件地址放入BOOTP分组中，使得服务器很容易获取客户的硬件地址。</p><p>这里出现了一个有趣的问题：TFTP服务器如何能将一个响应直接送回BOOTP客户？这个响应是一个UDP数据报，而服务器知道该客户的IP地址（可能通过读取服务器上的配置文件）。但如果这个客户向那个IP地址发送一个UDP数据报（正常情况下会处理UDP的输出），BOOTP服务器的主机就可能向那个IP地址发送一个ARP请求。但这个客户不能响应这个ARP请求，因为它还不知道它自己的IP地址！（这就是在RFC951中被称作“鸡和蛋”的问题。）</p><p>有两种解决办法：第一种，通常被Unix服务器采用，是服务器发一个ioctl请求给内核，为该客户在ARP高速缓存中设置一个条目（这就是命令arp-s所做的作工）。服务器能一直这么做直到它知道客户的硬件地址和IP地址。这意味着当服务器发送UDP数据报（即BOOTP应答）时，服务器的ARP将在ARP高速缓存中找到该客户的IP地址。</p><p>另一种可选的解决办法是服务器广播这个BOOTP应答而不直接将应答发回该客户。既然通常期望网络广播越少越好，因此这种解决方案应该只在服务器无法在它的ARP高速缓存设置一个条目的情况下使用。通常只有拥有超级用户权限才能在ARP高速缓存设置一个条目，如果没有这种权限就只能广播BOOTP应答。</p><h2 id=bootp-穿越路由器>BOOTP 穿越路由器<a hidden class=anchor aria-hidden=true href=#bootp-穿越路由器>#</a></h2><p>RARP的一个缺点就是它使用链路层广播，这种广播通常不会由路由器转发。这就需要在每个物理网络内设置一个RARP服务器。如果路由器支持BOOTP协议，那么BOOTP能够由路由器转发（绝大多数路由器厂商的产品都支持这个功能）。</p><p>这个功能主要用于无盘路由器，因为如果在磁盘的多用户系统被用作路由器，它就能够自己运行BOOTP服务器。此外，常用的Unix BOOTP服务器支持这种中继模式（relay mode）。但如果在这个物理网络内运行一个BOOTP服务器，通常没有必要将BOOTP请求转发到在另外网络中的另一个服务器。</p><p>研究一下当路由器（也称作“BOOTP中继代理”）在服务器的熟知端口（67）接收到BOOTP请求时将会发生什么。当收到一个BOOTP请求时，中继代理将它的IP地址填入收到BOOTP请求中的“网关IP地址字段”，然后将该请求发送到真正的BOOTP服务器（由中继代理填入网关字段的地址是收到的BOOTP请求接口的IP地址）。该代理中继还将跳数字段值加1（这是为防止请求被无限地在网络内转发。RFC 951认为如果跳数值到达3就可以丢弃该请求）。既然发出的请求是一个单播的数据报（与发起的客户的请求是广播的相反），它能按照一定的路由通过其他的路由器到达真正的BOOTP服务器。真正的BOOTP服务器收到这个请求后，产生BOOTP应答，并将它发回中继代理，而不是请求的客户。既然请求网关字段不为零，真正的BOOTP服务器知道这个请求是经过转发的。中继代理收到应答后将它发给请求的客户。</p><h2 id=特定厂商信息>特定厂商信息<a hidden class=anchor aria-hidden=true href=#特定厂商信息>#</a></h2><p>64字节的“特定厂商区域”含有服务器返回客户的可选信息。</p><p>如果有信息要提供，这个区域的前4个字节被设置为IP地址99.130.83.99。这可称作魔术甜饼(magic cookie)，表示该区域内包含信息。</p><p>这个区域的其余部分是一个条目表。每个条目的开始是1字节标志字段。其中的两个条目仅有标志字段：标志为0的条目作为填充字节（为使后面的条目有更好的字节边界），标志为255的条目表示结尾条目。第一个结尾条目后剩余的字节都应设置为这个数值（255）。</p><p>除了这两个1字节的条目，其他的条目还包含一个单字节的长度字段，后面是相应的信息。</p><p><img loading=lazy src=/images/tcp-ip/vendor-specific-area-format.jpg alt></p><p>子网掩码条目和时间值条目都是定长条目，因为它们的值总是占4个字节。时间偏移值是从1900年1月1日0时以来的秒数（UTC）。</p><p>网关条目是变长条目。长度通常是4的倍数，这个值是一个或多个供客户使用的网关（路由器）的IP地址。返回的第一个必须是首选的网关。</p><p>RFC 1533还定义了其他14个条目。其中最重要的可能是DNS名字服务器的IP地址条目，条目的志为6。其他的条目包括打印服务器、时间服务器等的IP地址。详细情况可参考RFC文档。</p><p>Host Requirements RFC文档推荐一个系统使用BOOTP来获悉它的子网掩码，而不是采用ICMP。</p><p>厂商说明区域的大小被限制为64字节。这对某些应用是个约束。一个新的称为动态主机配置协议DHCP（Dynamic Host Configuration Protocol）已经出现，但它不是替代BOOTP的。DHCP将这个区域的长度扩展到312字节，它在RFC 1541 [Droms 1993] 中定义。</p><h2 id=小结>小结<a hidden class=anchor aria-hidden=true href=#小结>#</a></h2><p>BOOTP使用UDP，它为引导无盘系统获得它的IP地址提供了除RARP外的另外一种选择。BOOTP还能返回其他的信息，如路由器的IP地址、客户的子网掩码和名字服务器的IP地址。</p><p>既然BOOTP用于系统引导过程，一个无盘系统需要下列协议才能在只读存储器中完成：BOOTP、TFTP、UDP、IP和一个局域网的驱动程序。</p><p>BOOTP服务器比RARP服务器更易于实现，因为BOOTP请求和应答是在UDP数据报中，而不是特殊的数据链路层帧。一个路由器还能作为真正BOOTP服务器的代理，向位于不同网络的真正BOOTP服务器转发客户的BOOTP请求。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://xuchengpeng.github.io/hugo-blog/tags/bootp/>BOOTP</a></li><li><a href=https://xuchengpeng.github.io/hugo-blog/tags/arp/>ARP</a></li><li><a href=https://xuchengpeng.github.io/hugo-blog/tags/rarp/>RARP</a></li></ul><nav class=paginav><a class=prev href=https://xuchengpeng.github.io/hugo-blog/post/markdown-complex-table/><span class=title>« Prev</span><br><span>Markdown 复杂表格</span>
</a><a class=next href=https://xuchengpeng.github.io/hugo-blog/post/tcp-ip-illustrated-volume1-tftp/><span class=title>Next »</span><br><span>TCP/IP 详解(卷一) TFTP：简单文件传送协议</span></a></nav></footer><script src=https://giscus.app/client.js data-repo=xuchengpeng/xuchengpeng.github.io data-repo-id="MDEwOlJlcG9zaXRvcnkxNDA1MzI1NTA=" data-category=Comments data-category-id=DIC_kwDOCGBbRs4CUv2b data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN data-loading=lazy crossorigin=anonymous async></script></article></main><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><footer class=footer><span>&copy; 2024 <a href=https://xuchengpeng.github.io/hugo-blog>Chuck</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span></footer><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>